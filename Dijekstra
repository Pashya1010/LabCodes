import java.util.*;

public class Dijkstra {

    // Edge class for adjacency list
    static class Edge {
        int to;
        int weight;
        Edge(int to, int weight) {
            this.to = to;
            this.weight = weight;
        }
    }

    // Node for priority queue (distance, vertex)
    static class Node implements Comparable<Node> {
        int vertex;
        int dist;
        Node(int vertex, int dist) {
            this.vertex = vertex;
            this.dist = dist;
        }
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.dist, other.dist);
        }
    }

    /**
     * Runs Dijkstra's algorithm from source on a graph represented by adjacency list.
     * @param graph adjacency list: graph[u] = list of edges from u
     * @param source source vertex (0-based)
     * @return pair of (distances array, parent array) to reconstruct paths
     */
    public static Pair dijkstra(List<List<Edge>> graph, int source) {
        int n = graph.size();
        final int INF = Integer.MAX_VALUE / 4;

        int[] dist = new int[n];
        int[] parent = new int[n]; // parent[v] = previous node on shortest path from source
        Arrays.fill(dist, INF);
        Arrays.fill(parent, -1);

        dist[source] = 0;
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.add(new Node(source, 0));

        boolean[] visited = new boolean[n];

        while (!pq.isEmpty()) {
            Node cur = pq.poll();
            int u = cur.vertex;
            if (visited[u]) continue; // skip outdated entries
            visited[u] = true;

            for (Edge e : graph.get(u)) {
                int v = e.to;
                int w = e.weight;
                if (w < 0) throw new IllegalArgumentException("Dijkstra requires non-negative weights");
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    parent[v] = u;
                    pq.add(new Node(v, dist[v]));
                }
            }
        }

        return new Pair(dist, parent);
    }

    // Utility to reconstruct path from source to target
    public static List<Integer> reconstructPath(int[] parent, int source, int target) {
        List<Integer> path = new ArrayList<>();
        if (parent[target] == -1 && source != target) {
            // target unreachable (unless source == target)
            return path;
        }
        int cur = target;
        while (cur != -1) {
            path.add(cur);
            if (cur == source) break;
            cur = parent[cur];
        }
        Collections.reverse(path);
        if (path.get(0) != source) return new ArrayList<>(); // unreachable
        return path;
    }

    // Small pair class to return results
    static class Pair {
        int[] dist;
        int[] parent;
        Pair(int[] dist, int[] parent) {
            this.dist = dist;
            this.parent = parent;
        }
    }

    // Example usage
    public static void main(String[] args) {
        int n = 6; // number of vertices (0..5)
        List<List<Edge>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());

        // add undirected edges (or directed as required)
        addEdge(graph, 0, 1, 7);
        addEdge(graph, 0, 2, 9);
        addEdge(graph, 0, 5, 14);
        addEdge(graph, 1, 2, 10);
        addEdge(graph, 1, 3, 15);
        addEdge(graph, 2, 3, 11);
        addEdge(graph, 2, 5, 2);
        addEdge(graph, 3, 4, 6);
        addEdge(graph, 4, 5, 9);

        int source = 0;
        Pair result = dijkstra(graph, source);

        System.out.println("Distances from source " + source + ":");
        for (int i = 0; i < result.dist.length; i++) {
            System.out.println(i + " -> " + (result.dist[i] == Integer.MAX_VALUE / 4 ? "INF" : result.dist[i]));
        }

        // Example: reconstruct path from source to 4
        int target = 4;
        List<Integer> path = reconstructPath(result.parent, source, target);
        if (path.isEmpty()) {
            System.out.println("No path from " + source + " to " + target);
        } else {
            System.out.println("Shortest path from " + source + " to " + target + ": " + path);
        }
    }

    // helper to add undirected edge; for directed graph call addDirectedEdge
    static void addEdge(List<List<Edge>> g, int u, int v, int w) {
        g.get(u).add(new Edge(v, w));
        g.get(v).add(new Edge(u, w));
    }
}
